<?php
/**
 * Plugin Name: Head Tags Reorder (Improved)
 * Description: This plugin captures the entire <head> section, parses it, and reorders the tags based on performance best practices. It works with tags generated by other plugins like Yoast SEO.
 * Version: 1.0
 * Author: Piotr Grono
 * Author URI: https://github.com/pgrono
 */

if (!defined('ABSPATH')) {
    exit; // Exit if accessed directly.
}

class Head_Tags_Reorder_Improved {

    public function __construct() {
        add_action('wp_head', [$this, 'start_buffer'], 0);
        add_action('wp_head', [$this, 'end_buffer_and_print'], 9999);
    }

    public function start_buffer() {
        ob_start();
    }

    public function end_buffer_and_print() {
        $head_html = ob_get_clean();

        if (empty($head_html)) {
            return;
        }

        $dom = new DOMDocument();
        libxml_use_internal_errors(true);
        // We add the XML declaration to ensure correct UTF-8 parsing of the fragment.
        $dom->loadHTML('<?xml encoding="UTF-8">' . $head_html, LIBXML_HTML_NOIMPLIED | LIBXML_HTML_NODEFDTD);
        libxml_clear_errors();

        $tags = [];
        foreach ($dom->childNodes as $node) {
            // We are only interested in element nodes (tags).
            if ($node->nodeType === XML_ELEMENT_NODE) {
                $tags[] = [
                    'html'   => $dom->saveHTML($node),
                    'weight' => $this->get_weight($node),
                ];
            } else {
                 // Preserve comments, but explicitly skip the XML Processing Instruction.
                 // This prevents `<?xml encoding="UTF-8">` from being printed.
                if ($node->nodeType === XML_PI_NODE) {
                    continue;
                }
                $tags[] = [
                    'html'   => $dom->saveHTML($node),
                    'weight' => -1, // Put comments and other nodes at the very end.
                ];
            }
        }

        // Sort tags based on weight, descending (higher weight comes first).
        usort($tags, function ($a, $b) {
            return $b['weight'] <=> $a['weight'];
        });

        // Print the sorted tags.
        foreach ($tags as $tag) {
            echo $tag['html'];
        }
    }

    /**
     * Assigns a weight to a given DOMNode for sorting.
     * Higher numbers have higher priority.
     *
     * @param DOMNode $node The HTML node to evaluate.
     * @return int The calculated weight.
     */
    private function get_weight($node) {
        if ($node->nodeType !== XML_ELEMENT_NODE) {
            return 0; // Not an element tag.
        }
        
        $tag_name = $node->nodeName;

        $weights = [
            'meta_charset'   => 100,
            'meta_http_equiv'=> 99,
            'title'          => 95,
            'meta_viewport'  => 90,
            'preconnect'     => 85,
            'async_script'   => 80,
            'critical_style' => 75, // Inline <style> tags
            'sync_styles'    => 70, // <link rel="stylesheet">
            'preload'        => 65,
            'sync_script'    => 60,
            'defer_script'   => 50,
            'meta_seo'       => 40, // Yoast description, etc.
            'canonical'      => 35,
            'prefetch'       => 20,
            'other_meta'     => 10,
            'other'          => 0,
        ];

        switch ($tag_name) {
            case 'title':
                return $weights['title'];

            case 'meta':
                if ($node->hasAttribute('charset')) {
                    return $weights['meta_charset'];
                }
                if ($node->hasAttribute('http-equiv')) {
                    return $weights['meta_http_equiv'];
                }
                if ($node->getAttribute('name') === 'viewport') {
                    return $weights['meta_viewport'];
                }
                // Broadly identify SEO and social media tags
                $name_attr = $node->getAttribute('name');
                $prop_attr = $node->getAttribute('property');
                if (strpos($name_attr, 'description') !== false || strpos($prop_attr, 'og:') === 0 || strpos($name_attr, 'twitter:') === 0) {
                    return $weights['meta_seo'];
                }
                return $weights['other_meta'];

            case 'link':
                $rel = $node->getAttribute('rel');
                switch ($rel) {
                    case 'preconnect':
                    case 'dns-prefetch':
                        return $weights['preconnect'];
                    case 'stylesheet':
                        return $weights['sync_styles'];
                    case 'preload':
                        return $weights['preload'];
                    case 'prefetch':
                    case 'prerender':
                        return $weights['prefetch'];
                    case 'canonical':
                        return $weights['canonical'];
                    default:
                        return $weights['other'];
                }

            case 'script':
                if ($node->hasAttribute('async')) {
                    return $weights['async_script'];
                }
                if ($node->hasAttribute('defer')) {
                    return $weights['defer_script'];
                }
                return $weights['sync_script']; // Treat inline and regular scripts as synchronous.

            case 'style':
                return $weights['critical_style'];
        }

        return $weights['other']; // Default for any other tag.
    }
}

new Head_Tags_Reorder_Improved();